# GC(Garbage Collection)

C/ C++ 에서는 메모리 누수를 막기 위해서 객체를 생성한 후 사용하지 않는 객체의 메모리를 프로그래머가 직접 해제해주어야 했습니다. 

하지만 Java 는 JVM이 구성된 JRE(자바 런타임 환경)이 제공되고, 그중 GC 가 자동으로 사용하지 않는 객체를 파괴합니다.

GC는 힙 메모리만 다룸. 

참조 : [Java 메모리 영역](./Java-메모리-영역)

일반적으로 다음과 같은 경우 GC의 대상이 됨.

1. 객체가 null인 경우 (예. String str = null ) 
2. 블럭 실행 종료 후, 블럭 안에서 생성된 객체
3. 부모 객체가 null 인 경우, 포함하는 자식 객체


### GC 내부에서 어떤 변화가 일어나는지?

GC 메모리 해제 과정

1. **marking** - 프로세스가 marking을 호출함. 사용되는 메모리인지 확인하는 과정. 모든 오브젝트를 스캔하기 때문에 많은 시간이 소요됨.
2. **Normal Deletion** - 참조되지 않는 객체(메모리 사용 안되는)를 제거하고 메모리를 반환하는 단계. 
3. **Compacting** - 퍼포먼스 향상을 위해 빈 공간을 없애기 위해 남겨진 참조객체들을 묶어줌. memory allocator가 빈 곳이 시작되는 위치를 기억했다가 새로운 오브젝트가 선언되면 그곳으로 할당.
   
<p>${{\color{#DD6565}하지만\ 위와\ 같이\ mark\ →\ compact\ 하는\ JVM은\ 비효율적임}}$</p>
새로 생성된 객체는 금방 사용하지 않는 상태가 되고, 

오래된 객체에서 신규 객체로의 참조가 매우 적다는 연구 가설을 바탕으로 Java 는 Young / Old 영역으로 메모리를 분할하도록 함. 

새로 생성된 객체는 young 영역으로.

young 영역에서 minor gc 가 일어나면서 살아남은 객체들은 old 영역으로, old 영역에서도 major gc 가 일어나면서 메모리 관리를 해주게 됨.
